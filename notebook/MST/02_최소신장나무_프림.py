import heapq

정점개수, 간선개수 = map(int, input().split())    # 각 정점과 간선의 개수
간선정보 = {인덱스:[] for 인덱스 in range(정점개수)}
for _ in range(간선개수):
    시작점, 도착점, 가중치, = map(int, input().split())
    간선정보[시작점].append([도착점, 가중치])
    간선정보[도착점].append([시작점, 가중치])   # 양방향 왔다리 갔다리해야 되니까 얘도 넣어줘야겠죠.

# 키, 최소신장나무, 우선순위 대기줄 준비
무한 = float('inf') # 일일이 쓰기 귀찮으니 여기서 정의하고 넘어감
실시간_변경_가중치 = [무한] * 정점개수
최소신장나무 = [False] * 정점개수
우선순위대기줄 = [] # 우선순위 대기줄; priority queue

# 시작 정점 선택: 0
실시간_변경_가중치[0] = 0   # 처음은 이동을 안하니까 빵이겠죠.
# 대기줄 시작 정점을 넣음 => (가중치, 정점 인덱스)
# 우선순위 대기줄 -> 이진힙 -> heapq 라이브러리 사용
heapq.heappush(우선순위대기줄, (0,0))
# 힙의 구조를 유지하면서 하나의 새로운 원소를 집어 넣어줌, 배열 정보와 어떤 원소를 집어 넣을지 입력해준다.
# 우선순위큐 -> 원소의 첫 번째 요소로 pop을 함 -> 그렇담 가중치를 우선순위로.

결과 = 0
while 우선순위대기줄:
    # 최소값 찾기
    현재값, 현재위치 = heapq.heappop(우선순위대기줄)
    if 최소신장나무[현재위치]: continue # 방문했는데 또 방문한 경우를 위해 조건 표시

    # 최소신장나무로 선택
    최소신장나무[현재위치] = True   # 방문으로 표시
    결과 += 현재값

    # 가중치 갱신 => 가중치 배열/대기줄
    for 다음지점, 다음지점_가중치 in 간선정보[현재위치]:  # 가고자 하는 곳 다음지점, 가중치 다음지점_가중치
        if not 최소신장나무[다음지점] and 실시간_변경_가중치[다음지점] > 다음지점_가중치:   # 실시간 변경 가중치에는 '무한'값이 들어있다. 이를 업데이트 해줘야한다.
            실시간_변경_가중치[다음지점] = 다음지점_가중치
            # 대기줄 갱신 => 새로운 (가중치, 정점) 삽입 => 필요없는 원소는 스킵
            heapq.heappush(우선순위대기줄, (실시간_변경_가중치[다음지점], 다음지점))